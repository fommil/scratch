/*
  this program converts .psf type 1 console fonts into the 8x16 C source format
  compatible with the linux kernel in drivers/video/console/font_8x16.c

  by Sam Halliday <fommil@yahoo.ie>

  TODO:
  - support non 8x16 sizes
  - allow fonts which have more than one unicode
*/

#include <stdio.h>
#include <stdlib.h>
#include "unicodes_iso.h"

void readunicodetable (FILE * file, unsigned int map[]);
void printgraph (FILE * file, unsigned int n, unsigned int no);
unsigned int matchunicode (unsigned int uni, unsigned int map[]);
unsigned int unicode (unsigned int charset, unsigned int entry);
void printnullgraph (unsigned int n);

int
main (int argc, char *argv[])
{
  FILE *inputfile;
  unsigned char temp;
  unsigned int fontmap[255];
  unsigned int n, nm, iso;

  if (argc < 2)
    {
      fprintf (stderr, "Usage: %s <unicode> <input.psf>\n"
	       "Examples: %s 15 iso15-16.psf > iso15-16.c\n"
               "          gzip -cd iso15-16.psf.gz | %s 15 > iso15-16.c", argv[0], argv[0], argv[0]);
      exit (EXIT_FAILURE);
    }
  if (3 == argc){
    if ((inputfile = fopen (argv[2], "r")) == NULL)
      {
        fprintf (stderr, "Error: Cannot open %s for read!\n", argv[2]);
        exit (EXIT_FAILURE);
      }
  }
  else{
    /* inputfile=stdin; */
    /* reading from stdin breaks things... maybe to do with the fseek calls or something */
    fprintf (stderr, "Error: Reading from stdin is not yet supported\n");
    exit (EXIT_FAILURE);
  }
  iso = atoi (argv[1]);
  fprintf (stderr, "Using iso-8859-%u\n", iso);

  /* check the magic number 0x36 0x04 */
  if (!((0x36 == fgetc (inputfile)) && (0x04 == fgetc (inputfile))))
    {
      fprintf (stderr, "Error: `%s' is not a PSF type 1 file\n", argv[1]);
      return 1;
    }

  /* check the mode */
  temp = fgetc (inputfile);
  if (!((0x01 == temp) || (0x02 == temp) || (0x04 == temp) || (0x05 == temp)))
    fprintf (stderr, "Warning: font uses an unknown mode\n");

  /* check the size */
  if (0x10 != fgetc (inputfile))
    {
      fprintf (stderr, "Error: Font is not 16 pixels high!\n");
      return 1;
    }

  printf ("/**********************************************/\n"
	  "/*                                            */\n"
	  "/*     Font file generated by psfto8x16c      */\n"
	  "/*                                            */\n"
	  "/**********************************************/\n\n"
	  "#include <linux/font.h>\n\n"
	  "#define FONTDATAMAX 4096\n\n"
	  "static unsigned char fontdata_8x16[FONTDATAMAX] = {\n\n");

  /* get the unicode table */
  readunicodetable (inputfile, fontmap);

  for (n = 0; n < 256; n++)
    {
      if (unicode (iso, n) == fontmap[n])
	printgraph (inputfile, n, n);
      else
	{
	  nm = matchunicode (unicode (iso, n), fontmap);
	  if (256 != nm)
	    {
	      printgraph (inputfile, nm, n);
	    }
	  else
	    {
	      fprintf (stderr,
		       "Warning: character %u not matched against U+%04x\n",
		       n, unicode (iso, n));
	      printnullgraph (n);
	    }
	}

    }

  printf ("};\n\n\n"
	  "struct font_desc font_vga_8x16 = {\n"
	  "\tVGA8x16_IDX,\n"
	  "\t\"VGA8x16\",\n"
	  "\t8,\n" "\t16,\n" "\tfontdata_8x16,\n" "\t0\n" "};\n");

  fclose (inputfile);
  return 0;
}

unsigned int
leread (FILE * file)
{
  unsigned char c1, c2;
  c1 = fgetc (file);
  c2 = fgetc (file);
  /* return little endian */
  return (c2 << 8) + c1;
}

void
sepcheck (FILE * file, unsigned int n)
{
  int b = leread (file);

  if (0xffff != b)
    {
      if (0xfeff == b)
	fprintf
	  (stderr,
	   "Warning: graphic %u uses <seq> which i cannot deal with\n", n);
      else
	fprintf
	  (stderr,
	   "Warning: graphic %u ignoring alternate mapping to U+%04x (this is a known bug)\n",
	   n, b);
      /* call ourselves recursively until we find an 0xffff */
      sepcheck (file, n);
    }
}

void
readunicodetable (FILE * file, unsigned int map[])
{
  unsigned int n, c;

  /*
    <unicodedescription> := <uc>*<seq>*0xFFFF
    <seq> := 0xFFFE<uc><uc>*

    * denotes zero or more occurrences of the preceding item.
    <uc> := 2-byte little endian Unicode value
  */
  fseek (file, 4100, SEEK_SET);
  for (n = 0; (256 > n) && (0 == feof (file)); n++)
    {
      /* c is little endian */
      c = leread (file);

      if (0xffff == c)
	{
	  /* printf ("0x%02x\t\n", n); */
	  map[n] = 0;
	}
      else
	{
	  /* printf ("0x%02x\t U+%04x\n", n, c); */
	  map[n] = c;
	  sepcheck (file, n);
	}
    }
  if (256 != n)
    {
      fprintf (stderr,
	       "Error: reached EOF when reading unicode for graphic %u\n",
	       n - 1);
      fclose (file);
      exit (EXIT_FAILURE);
    }
}

unsigned int
unicode (unsigned int charset, unsigned int entry)
{
  if ((12 == charset) || (16 < charset))
    {
      fprintf
	(stderr, "Error: Request for iso-8859-%u. does not exist.\n",
	 charset);
      exit (EXIT_FAILURE);
    }
  else if (255 < entry)
    {
      fprintf
	(stderr,
	 "Error: Request for iso-8859-%u entry %u, but limited to 255 characters.\n",
	 charset, entry);
      exit (EXIT_FAILURE);
    }
  else if (160 > entry)
    return unicodes_iso_8859[0][entry];
  else
    return unicodes_iso_8859[charset][entry - 160];
}

unsigned int
matchunicode (unsigned int uni, unsigned int map[])
{
  unsigned int n;
  /* optimisation is to start at 160 first as all characters below that
     are usually in order */
  for (n = 160; n < 256; n++)
    {
      if (uni == map[n])
	return n;
    }
  for (n = 0; n < 160; n++)
    {
      if (uni == map[n])
	return n;
    }
  return 256;
}

void
printbinary (unsigned char c)
{
  unsigned char c1, c2, c3, c4, c5, c6, c7, c8;
  c1 = (c >> 7);
  c2 = ((c - (c1 << 7)) >> 6);
  c3 = ((c - (c1 << 7) - (c2 << 6)) >> 5);
  c4 = ((c - (c1 << 7) - (c2 << 6) - (c3 << 5)) >> 4);
  c5 = ((c - (c1 << 7) - (c2 << 6) - (c3 << 5) - (c4 << 4)) >> 3);
  c6 = ((c - (c1 << 7) - (c2 << 6) - (c3 << 5) - (c4 << 4) - (c5 << 3)) >> 2);
  c7 = ((c - (c1 << 7) - (c2 << 6) - (c3 << 5) - (c4 << 4) -
	 (c5 << 3) - (c6 << 2)) >> 1);
  c8 = (c - (c1 << 7) - (c2 << 6) - (c3 << 5) - (c4 << 4) -
	(c5 << 3) - (c6 << 2) - (c7 << 1));
  printf ("%u%u%u%u%u%u%u%u", c1, c2, c3, c4, c5, c6, c7, c8);
}

void
printablechar (unsigned char c)
{
  /* ASCII control sequences */
  if (127 == c)
    printf ("DEL");
  else if (32 > c)
    printf ("%s", asciicntrl[(int) c]);

  /* ISO-8859 control sequences */
  else if ((127 < c) && (160 > c))
    printf ("%s", isocntrl[(int) (c - 128)]);

  /* printable characters */
  else
    printf ("%c", c);
}

void
printgraph (FILE * file, unsigned int n, unsigned int no)
{
  unsigned int i;
  unsigned char byte;

  if (255 < n)
    {
      fprintf (stderr, "Error: printgraph() recieved a request %u > 255\n",
	       n);
      fclose (file);
      exit (EXIT_FAILURE);
    }

  printf ("\t/* %d 0x%02x '", no, no);
  printablechar (no);
  printf ("'*/\n");

  fseek (file, 4 + (16 * n), SEEK_SET);

  for (i = 0; i < 16; i++)
    {
      byte = fgetc (file);
      printf ("\t0x%02x, /* ", byte);
      printbinary (byte);
      printf (" */\n");
    }
  printf ("\n");
}

void
printnullgraph (unsigned int n)
{
  unsigned int i;

  printf ("\t/* %u 0x%02x '", n, n);
  printablechar (n);
  printf ("'. No graph found. */\n");
  for (i = 0; i < 16; i++)
    {
      printf ("\t0x%02x, /* ", 0);
      printbinary (0);
      printf (" */\n");
    }
  printf ("\n");
}
